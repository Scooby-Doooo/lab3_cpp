# Умови програмного проєкту №3 — Варіант 16

## 1. Постановка задачі
[cite_start]Необхідно реалізувати багатопотокове обчислення на основі орієнтованого графа (схеми), що визначає залежності між діями[cite: 2]. 

### [cite_start]Параметри варіанту 16 [cite: 49]
* **Схема:** №3 (див. опис залежностей нижче).
* **Кількість робочих потоків (`nt`):** 5.
* **Кількість дій у кожному наборі:**
    * `a` = 7
    * `b` = 6
    * `c` = 5
    * `d` = 6
    * `e` = 4
    * `f` = 7
    * `g` = 5
    * `h` = 5
    * `i` = 8
    * `j` = 5

### Логіка залежностей (Схема №3)
На основі візуального аналізу наданого зображення схеми №3, залежності між діями є такими:
1.  **Старт** → виконується набір **a**.
2.  Після завершення **a** паралельно можуть виконуватися набори **b**, **c**, **d**.
3.  Після завершення **b** → може виконуватися **e**.
4.  Після завершення **c** → можуть виконуватися **f** та **g**.
5.  Після завершення **d** → може виконуватися **h**.
6.  Після завершення обох **e** та **f** (точка синхронізації) → виконується **i**.
7.  Після завершення обох **g** та **h** (точка синхронізації) → виконується **j**.
8.  Обчислення завершується, коли виконані дії **i** та **j**.

[cite_start]*Примітка:* Дії вважаються залежними, якщо одна використовує результат іншої[cite: 6]. [cite_start]Дії з вхідних дуг мають бути повністю завершені перед початком наступних[cite: 4].

---

## 2. Вимоги до реалізації

### Технічні обмеження
1.  [cite_start]**Мова:** C++[cite: 22].
2.  [cite_start]**Потоки:** * Дозволено використовувати `thread`, `jthread`[cite: 23].
    * [cite_start]Всього дозволено запустити рівно `nt` (5) потоків + 1 головний (`main`)[cite: 25].
    * [cite_start]Заборонено створювати нові потоки динамічно замість завершених (перезапуск рахується як новий потік)[cite: 26].
    * [cite_start]Головний потік (`main`) **не може** виконувати обчислювальні дії, він лише керує запуском[cite: 27].
3.  [cite_start]**Синхронізація:** Дозволено використовувати тільки `semaphore`, `latch`, `barrier`[cite: 23].
4.  [cite_start]**Введення/Виведення:** Використовувати `osyncstream` для потокобезпечного виводу[cite: 24].

### Планування (Scheduling)
* [cite_start]Розподіл дій між 5-ма потоками має бути **hardcoded** (статичним)[cite: 28].
* Ви повинні заздалегідь (на етапі написання коду) визначити, який потік виконує яку конкретну дію (наприклад, *Потік 1 виконує a1, a2, b1...*).
* [cite_start]Динамічний розподіл (черги задач, work-stealing) **заборонений**[cite: 28].
* [cite_start]**Мета оптимізації:** Мінімізувати загальний час виконання, завантаживши потоки максимально щільно, ніби кожна дія триває однаковий час[cite: 10, 12].

---

## 3. Формат функцій та виводу

### Функція-заглушка
[cite_start]Кожна дія (наприклад, 3-тя дія з набору 'a') має реалізовуватися викликом функції `f(name, index)`[cite: 13].

Приклад виклику для дії `a3`:
```cpp
f('a', 3);
````

### Вивід у консоль (або файл)

1.  На початку роботи:
    ```text
    Обчислення розпочато.
    ```
    [cite\_start][cite: 17, 18]
2.  Під час виконання кожної дії (всередині функції `f`):
    ```text
    З набору a виконано дію 3.
    ```
    [cite\_start][cite: 15, 16]
3.  По завершенню всіх дій:
    ```text
    Обчислення завершено.
    ```
    [cite\_start][cite: 19, 20]

-----

## 4\. Результат

Для здачі необхідно підготувати:

1.  Вихідний код.
2.  Скріншот збірки та роботи програми.
3.  [cite\_start]Текстовий файл з результатом роботи (redirect output `prog.exe > results.txt`)[cite: 29, 30, 32].

<!-- end list -->